# Operationalising golangci-lint
: @formatter:off
Leveraging Go Linters for Robust Code Quality
01 Dec 2024
Tags: linters, golangci-lint
Summary: Configuring golangci-lint for better Go code.

Suhas Karanth
Staff Engineer, Netskope
skaranth@netskope.com
https://github.com/sudo-suhas
https://www.linkedin.com/in/skaranth90/

: @formatter:on

## Agenda

- What are linters?
- Why use linters?
- Examples
- How to use `golangci-lint`?

## What are linters?

A linter is a program which performs static code analysis to flag programming errors, bugs,
stylistic errors and suspicious constructs. The term originates from a Unix utility that examined C
language source code.

In simple terms, a linter identifies and flags predefined 'patterns'. These patterns could be
related to potential bugs or code style.

: Static code analysis means that we analyze the code without executing it.

## Why use linters?

- **[Shift-Left Testing][shift-left-testing]**: _Bugs are cheap when caught young_. We would be
  moving bug detection from tests to linters. Faster feedback means improved quality and speed of
  delivery.
- **Code style**:
	- Consistency
	- Readability
	- Slightly faster speed of delivery
	- Avoid inconsequential debates (ex: `gofmt` for tabs vs spaces)
- **Guardrails**: A good linter setup acts as guardrails for both experienced and new developers to
  avoid tricky bugs; but it is more helpful for newbies. Not all bugs are easily caught in tests
  either.

[shift-left-testing]: https://www.drdobbs.com/shift-left-testing/184404768

: [Shift-Left Testing]: If you think of the feature lifecycle, we have product requirement
: gathering, architectural design, implementation with unit tests, integration tests etc. The idea
: is to try and move the identification of the issue 'left'. So if there was a problem that you
: usually catch in integration tests, try to catch in unit tests. In this case, detection of bug can
: move from unit tests to linters. Ideally, the IDE should flag issues right when we are coding.
: [Consistency] For code constructs + package/function/type names. Ex: Effective Go guidelines on
: package names. Consistency helps readability which in turn helps maintainability.

## Examples

: To understand why we would want to use linters, lets look at some examples. I am going to show
: some code snippets and I want you to try and spot the issue. The examples are a bit contrived but
: that should be okay for the purposes of this discussion. I will also show an example of a bug
: that is harder to catch in tests.

## Example #1

.code demo-code/snippets/errorsas.go /START BROKEN/,/END BROKEN/

## Example #1

Issue can be fixed by passing a pointer to `*MyError`, the type implementing error.

.code demo-code/snippets/errorsas.go /START FIXED/,/END FIXED/

`go vet` can flag the issue in this case. By default, `go test` runs a high-confidence subset of
`go vet` checks - `atomic`, `bool`, `buildtags`, `directive`, `errorsas`, `ifaceassert`, `nilfunc`,
`printf`, and `stringintconv`.

```
$ go tool vet help errorsas
errorsas: report passing non-pointer or non-error values to errors.As

The errorsas analysis reports calls to errors.As where the type
of the second argument is not a pointer to a type implementing error.
```

For the example from the previous slide, we get the following error:

```
snippets/errorsas.go:21:6: second argument to errors.As must be a non-nil pointer to either a
type that implements error, or to any interface type
```

## Example #2

## Example #2

.play -edit demo-code/urlqueryv1/main.go /START/,/END/

## Example #2

One of the _many_ detections in [staticcheck][staticcheck-sa4027] can flag this:

[staticcheck-sa4027]: https://staticcheck.dev/docs/checks/#SA4027

```
snippets/tbd.go:15:2: SA4027: (*net/url.URL).Query returns a copy, modifying it doesn't change
the URL (staticcheck)
        u.Query().Set("search", params.Search)
        ^
```

Small changes are needed to fix the issue:

.play -edit demo-code/urlqueryv2/main.go /START/,/END/

## Example #3

: Example where it is harder to catch the issue in tests

## Example #3

.code demo-code/rowserrv1/main.go /START FETCH/,/END FETCH/

## Example #3

.play -edit demo-code/rowserrv1/main.go /START DEMO/,/END DEMO/

## Example #3

Linter that can catch this issue - [rowserrcheck][rowserrcheck]:

```
rowserrv1/main.go:82:30: rows.Err must be checked (rowserrcheck)
        rows, err := db.QueryContext(ctx, qry)
                                    ^
```

[rowserrcheck]: https://github.com/jingyugao/rowserrcheck

Issue can be fixed with a `rows.Err()` check:

.play -edit demo-code/rowserrv2/main.go /START/,/END/

## Linting in Go

## Linting in Go

1. Why `golangci-lint`?
2. Why do we need extensive configuration?
3. Configuration builder sheet walkthrough.

## golangci-lint

[https://golangci-lint.run/][golangci-lint-home]

> _It runs linters in parallel, uses caching, supports YAML configuration,
> integrates with all major IDEs, and includes over a hundred linters._

[golangci-lint-home]: https://golangci-lint.run/

<table style="margin-top:  -10px;">
<tr>
<td><b>Popular</b></td>
<td>

.image assets/golangci-lint-popularity.png _ 550

</td>
</tr>
<tr>
<td><b>Actively maintained</b></td>
<td>

.image assets/golangci-lint-pulse-insights.png 350 _

</td>
</tr>

</table>

: What is golangci-lint? It is a linter aggregator that provides a performant, consistent interface
: for running 100+ linters.
: --
: Among the linters that golangci-lint integrates, there are 2 variants. A linter that has 1 or few
: related pattern detections like noctx and errorlint. Or a linter that has large number of rules
: like staticcheck, goritic and revive.

## Adopting golangci-lint

Just run `golangci-lint` in your project and you are done.

```
$ golangci-lint run
```

_Right?_

: Hopefully, I have convinced you about using golangci-lint. So just run golangci-lint in your
: project and you are done, right?

## Need for configuration

Unfortunately, just running `golangci-lint` is not enough. We need to do some work to get the best
out of `golangci-lint`.

**Default configuration**

`golangci-lint` integrates 100+ linters but by default, it enables a very small set of linters:

- [errcheck][errcheck]
- [gosimple][gosimple]
- [govet][govet]
- [ineffassign][ineffassign]
- [staticcheck][staticcheck]
- [unused][unused]

[errcheck]: https://github.com/kisielk/errcheck

[gosimple]: https://github.com/dominikh/go-tools/tree/master/simple

[govet]: https://pkg.go.dev/cmd/vet

[ineffassign]: https://github.com/gordonklaus/ineffassign

[staticcheck]: https://staticcheck.io/

[unused]: https://github.com/dominikh/go-tools/tree/master/unused

## Useful linters disabled by default

There are many more extremely useful linters that can help uncover bugs and ensure consistent code
style. Some examples:

- [errorlint][errorlint]: find code that will cause problems with the error wrapping scheme
  introduced in Go 1.13.
- [gci][gci]: deterministic package import order.
- [gocognit][gocognit]: enforce limit on cognitive complexity of functions.
- [gofumpt][gofumpt]: a stricter gofmt.
- [gosec][gosec]: inspect source for **security issues**.
- [noctx][noctx]: find HTTP requests without `context.Context`.
- [rowserrcheck][rowserrcheck], [sqlclosecheck][sqlclosecheck]: ensure correct usage of
  `database/sql` package.

In addition to these, there are linters with numerous rules such as [gocritic][gocritic]
and [revive][revive] that are also disabled by default.

[errorlint]: https://github.com/polyfloyd/go-errorlint

[gci]: https://github.com/daixiang0/gci

[gocognit]: https://github.com/uudashr/gocognit

[gofumpt]: https://github.com/mvdan/gofumpt

[gosec]: https://github.com/securego/gosec

[noctx]: https://github.com/sonatard/noctx

[rowserrcheck]: https://github.com/jingyugao/rowserrcheck

[sqlclosecheck]: https://github.com/ryanrolds/sqlclosecheck

[gocritic]: https://github.com/go-critic/go-critic

[revive]: https://github.com/mgechev/revive

: gosec deserves a special mention since it is able to catch security issues like SQL and command
: injection.

## So just enable everything?

## So just enable everything?

No, for a few reasons:

- **Noise:** Not all linters are useful for your specific use-case. For
  example, [decorder][decorder] is declaration order linter for Go. We sometimes intentionally
  colocate different declaration types out of order to aid cognition so we wouldn't want to enable
  it.
- **Ineffective:** Some linters are useful in a specific context. For
  example, [zerologlint][zerologlint] detects the wrong usage of zerolog. If you aren't using
  zerolog, this isn't useful.
- **Duplication:** With the number of linters supported by `golangci-lint`, it is inevitable that
  there would be checks duplicated between different linters. For example, `govet` has a
  "`structtag`" check that is duplicated by `revive`'s "`struct-tag`" check.
- **Premature optimisation:** There are some linters that should be enabled only if the specific
  execution environment has performance constraints. For example, [prealloc][prealloc] is a linter
  that can help with minimising allocations that, IMO, should only be enabled if needed.

[decorder]: https://gitlab.com/bosi/decorder

[zerologlint]: https://github.com/ykadowak/zerologlint

[prealloc]: https://github.com/alexkohler/prealloc

: I know of 40+ checks that are duplicated across different linters. Disabling duplicate checks and
: linters has a performance benefit as well.
: I hope you can see why we need to configure golangci-lint to enable the linters that we want. But
: there is 1 additional aspect I want to touch on w.r.t configuration.

## Individual linter configuration

For many of the linters, individual configuration is needed to get the desired behaviour. For
example, for `gci`, we would want to have the following configuration:

```
[linters-settings.gci]
  sections = [
    # Standard section: captures all standard packages.
    "standard",
    # Default section: contains all imports that could not be matched to another section type.
    "default",
    # Custom section: groups all imports with the specified Prefix.
    "prefix(github.com/netskope,github.com/netSkope)",
  ]
  custom-order = true
```

This configuration is also necessary for linters that include multiple rules such as `gocritic` and
`revive` because we would want a subset of the available rules.

## Configuration builder

[golangci-lint-linters-v1.61.0 sheet][golangci-lint-linters-v1-61-0-sheet]

This sheet helps to manage the configuration for `golangci-lint`.

[golangci-lint-linters-v1-61-0-sheet]: https://docs.google.com/spreadsheets/d/1-pg0JNHOoN8bRer5bRuZFYYPpspYXdwe5wIKjglcvsE/edit?usp=sharing

: Typically, you don't need to frequently update the configuration for golangci-lint. And it is
: quite common to copy and modify configuration from 1 repo to another. But it is still useful to
: have an excel sheet if you are starting from scratch for being able to discuss and gather feedback
: on the proposed configuration. And when I had finished building the sheet, I used some extra time
: I had to generate the config from the sheet itself. So this might be a bit of overengineering.
: --
: The configuration was last updated for version v1.61.0 of golangci-lint.
: --
: The configuration is updated in a few seconds whenever any change is made in the sheet by the Apps
: Script attached to the project (see triggers.gs).

## Integrating golangci-lint into an existing project

When we are creating a new project, it is straightforward to integrate `golangci-lint` into it.

However, if we are integrating `golangci-lint` into a pre-existing project where either the linter
was not integrated or the configuration was minimal, we need a strategy to iteratively fix the large
number of issues that would be reported by the linter with the new/updated configuration.

Fixing all the issues in a single effort can be inhibitively expensive.

## Integrating golangci-lint into an existing project

`golangci-lint` provides a mechanism for gradual adoption by reporting issues only for new and
modified lines in the commit. See [golangci-lint FAQ][golangci-lint-faq].

```
$ golangci-lint run --help
Run the linters

Usage:
  golangci-lint run [flags]
Flags:
 ...
      --new-from-rev REV               Show only new issues created after git revision REV
```

The official Github action provided by authors of `golangci-lint` also supports a configuration
option `only-new-issues` which can show only the issues that were introduced by a pull request etc.
See [github.com/golangci/golangci-lint-action#only-new-issues][golangci-lint-action-only-new-issues].

I would also recommend picking a subset of reported issues and fixing those when integrating the
updated configuration. Ex: [github.com/goto/compass/pull/38][compass-pr].

[golangci-lint-faq]: https://golangci-lint.run/welcome/faq/#how-to-integrate-golangci-lint-into-large-project-with-thousands-of-issues

[golangci-lint-action-only-new-issues]: https://github.com/golangci/golangci-lint-action#only-new-issues

[compass-pr]: https://github.com/goto/compass/pull/38

## Should do

- Configure `golangci-lint` and formatters right into the IDE. For `golangci-lint`,
  see [golangci-lint.run/welcome/integrations/][golangci-lint-integrations]. If you are using
  `gofumpt`, which I would highly recommend, the instructions for setting it up are documented in
  the [readme][gofumpt-installation].
- Integrate pre-commit: [https://pre-commit.com/][pre-commit].

[golangci-lint-integrations]: https://golangci-lint.run/welcome/integrations/

[gofumpt-installation]: https://github.com/mvdan/gofumpt?tab=readme-ov-file#installation

[pre-commit]: https://pre-commit.com/

: Both VSCode and Goland have plugin support for surfacing issues flagged by golangci-lint.

## Summary

- Linters detect and flag predefined 'patterns'.
- Using linters helps to left shift detections and improves quality and speed of delivery. It helps
  bring consistency and improves readability.
- We saw examples that show different scenarios in which linters can catch the issue.
- A bit of extra work to configure `golangci-lint` goes a long way to get the best out of it.
- The configuration builder sheet can help you get started.
- For existing projects, leverage the `--new-from-rev` option provided by `golangci-lint` to fix
  issues iteratively.

## Special Thank You

The work done by authors of various linters and `golangci-lint` is immensely valuable and I am very
grateful to them. Thank you!

## Questions?

Talk material:

.image assets/bitly-qr-code.png 350 _
<p style="text-align: center;">
  <a href="https://bit.ly/gophercon-in-2024-linters-v1">https://bit.ly/gophercon-in-2024-linters-v1</a> 
</p>

[bitly-link]: https://bit.ly/go-mtp-blr-linters-v1
